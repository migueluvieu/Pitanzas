{"version":3,"sources":["models/mongoose/user-mongoose.ts"],"names":["UserMongoose","UserMongoose.constructor","UserMongoose.model"],"mappings":"AACA,IAAY,QAAQ,WAAM,UAAU,CAAC,CAAA;AA0BrC;;;;GAIG;AACH,IAAI,OAAO,GAAoB,IAAI,QAAQ,CAAC,MAAM,CAAC;IAC/C,IAAI,EAAE;QACJ,IAAI,EAAE,MAAM;KACb;IACD,GAAG,EAAE;QACH,IAAI,EAAE,MAAM;KACb;IACD,KAAK,EAAE;QACL,IAAI,EAAE,MAAM;KACb;CACF,EAAE;IACD,qHAAqH;IACjH,sFAAsF;IACtF,qEAAqE;IACzE,UAAU,EAAE,IAAI;CACjB,CAAC,CAAA;AACF;;;;KAIK;AAEP;;;;;;GAMG;AACF,IAAI,MAAM,GAAyB,QAAQ,CAAC,KAAK,CAAU,UAAU,EAAE,OAAO,CAAC,CAAC;AAGjF;;;;;GAKG;AACH;IAAAA;IAIAC,CAACA;IAHCD,sBAAWA,qBAAKA;aAAhBA;YACEE,MAAMA,CAACA,MAAMA,CAACA;QAChBA,CAACA;;;OAAAF;IACHA,mBAACA;AAADA,CAJA,AAICA,IAAA;AAJY,oBAAY,eAIxB,CAAA","file":"models/mongoose/user-mongoose.js","sourcesContent":["\r\nimport * as mongoose from 'mongoose';\r\n\r\n/**\r\n * Lo más importante, se mantiene una vble  _model de tipo modelo de moongose tipado a IUser  \r\n *  var _model = mongoose.model <IUser> ('Customer', _schema);\r\n * de tal forma que cuando se haga el _model.find() y demás, el onResolve ya devolverá un IUser. Todo esto es gracias a que \r\n * la interface extiende de mongoose.Document\r\n * Atacamos a mongo a través de la vble _model\r\n */\r\n\r\n/**\r\n * \r\n * Interface para conectar nuestro modelo con el modelo mongoose.\r\n * Es necesario que extienda de mongoose.Document para luego poder\r\n * tipificar con ella el modelo (mongoose.Model<IUser> en módulo user-mongoose)\r\n * @export\r\n * @interface IUser\r\n * @extends {mongoose.Document}\r\n */\r\nexport interface IUser extends mongoose.Document {\r\n   _id:string;\r\n   name: string;\r\n   age: number;\r\n  email: string;\r\n}\r\n\r\n/**\r\n * MongooseSchema\r\n * @type {\"mongoose\".Schema}\r\n * @private\r\n */\r\nvar _schema: mongoose.Schema = new mongoose.Schema({\r\n    name: {\r\n      type: String\r\n    },\r\n    age: {\r\n      type: String\r\n    },\r\n    email: {\r\n      type: String\r\n    }\r\n  }, {\r\n    //al poner esto, automáticamente se crean dos nuevos campos al esquema, fechas de auditoría createdAt and updatedAt. \r\n        //Al hacer save, las fechas se añaden automáticamente (depende si insertar-actualizar)\r\n        //se puede consultar http://mongoosejs.com/docs/guide.html#timestamps\r\n    timestamps: true\r\n  })\r\n  /* esto son \"triggers\" que se pueden añadir\r\n    .pre('save', function(next) {\r\n    this.updated = new Date();\r\n    next();\r\n  });*/\r\n\r\n/**\r\n * Mongoose.Mode. Se define la vble _model como modelo de moongose \r\n * pero tipado con IUser (interface que a su vez extiende de mongoose.Document) \r\n * Así el _model.find() y demás, el onResolve ya devolverá un IUser\r\n * @type {Model<IUser>}\r\n * @private\r\n */\r\n var _model:mongoose.Model<IUser> = mongoose.model <IUser> ('Customer', _schema);\r\n\r\n\r\n/**\r\n * \r\n * Se encapsula la vble model que utilizaremos en el DAO\r\n * @export\r\n * @class UserMongoose\r\n */\r\nexport class UserMongoose{\r\n  static get model ():mongoose.Model<IUser>{\r\n    return _model;\r\n  }\r\n}\r\n\r\n\r\n\r\n"],"sourceRoot":"/source/"}